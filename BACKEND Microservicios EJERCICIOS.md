## **Video  Fundamentos \+ Docker \+ Git**

https://www.youtube.com/watch?v=wj766sxHZrM\&t=20s

üéØ **Objetivo:** entender qu√© son los microservicios, instalar y configurar Docker y Git.  
 üïê **Duraci√≥n del bloque a visualizar:**  
 ‚û°Ô∏è **Desde minuto 0:00 hasta minuto 26:00** del video.

---

### **üìπ Detalle minuto a minuto**

| Minutos | Tema | Estado | Instrucci√≥n |
| ----- | ----- | ----- | ----- |
| **0:00 ‚Äì 5:00** | Introducci√≥n general y objetivos del curso. Qu√© son los microservicios. | ‚úÖ **Obligatorio** | Escuchar completo. Conceptos base que usar√°n toda la semana. |
| **5:00 ‚Äì 10:00** | Principios: autonom√≠a, acoplamiento, escalabilidad, observabilidad. | ‚úÖ **Obligatorio** | Tomar notas ‚Äî base te√≥rica para arquitectura modular. |
| **10:00 ‚Äì 20:00** | Instalaci√≥n y configuraci√≥n de Docker Desktop y Docker Compose (WSL2). | ‚úÖ **Obligatorio** | Repetir los pasos y dejar Docker funcionando localmente. |
| **20:00 ‚Äì 24:00** | Configuraci√≥n de Git y GitHub (ramas Main / Staging). | ‚úÖ **Obligatorio** | Crear repo propio del equipo. |
| **24:00 ‚Äì 26:00** | Inicio de explicaci√≥n de Kafka / Confluent Cloud. | ‚ö†Ô∏è **Opcional ‚Äî saltar o ver solo como referencia.** | No aplicable para esta semana (Kafka se ve en la demo final). |

# **üß≠ D√çA 1 ‚Äî Fundamentos \+ Entorno Docker / Git**

## **üéØ Objetivo general**

Comprender qu√© es una arquitectura de microservicios y preparar el entorno de trabajo para los siguientes d√≠as.  
 El grupo debe terminar el d√≠a con una base funcional en **Docker Compose**, donde cada servicio puede ser levantado de forma independiente.

---

## **üß© Conceptos que deben dominar**

* Diferencia entre monolito y microservicios

* Principios b√°sicos: **autonom√≠a, responsabilidad √∫nica, acoplamiento flexible, escalabilidad y observabilidad**

* Estructura de proyecto ‚Äúmulti-servicio‚Äù

* Uso de Docker \+ Docker Compose para levantar contenedores

* Control de versiones en Git (ramas Main y Staging)

---

## **üõ†Ô∏è Tareas pr√°cticas paso a paso**

### **1Ô∏è‚É£ Crear la estructura base del proyecto**

`mkdir microservices-lab`  
`cd microservices-lab`  
`mkdir auth-service blog-service email-service frontend reverse-proxy`

Dentro de cada carpeta, crear un `README.md` vac√≠o describiendo qu√© contendr√°.

---

### **2Ô∏è‚É£ Inicializar Git y GitHub**

`git init`  
`git branch -M main`  
`git add .`  
`git commit -m "Estructura inicial del laboratorio de microservicios"`

Luego crear el repo remoto y vincularlo:

`git remote add origin https://github.com/<tu-org>/microservices-lab.git`  
`git push -u origin main`

---

### **3Ô∏è‚É£ Preparar el entorno Docker Compose**

Crea en la ra√≠z un archivo `docker-compose.yml`:

`version: "3.9"`  
`services:`  
  `postgres:`  
    `image: postgres:15`  
    `container_name: db_postgres`  
    `restart: always`  
    `environment:`  
      `POSTGRES_USER: devuser`  
      `POSTGRES_PASSWORD: devpass`  
      `POSTGRES_DB: main_db`  
    `ports:`  
      `- "5432:5432"`  
    `volumes:`  
      `- pgdata:/var/lib/postgresql/data`

  `redis:`  
    `image: redis:7`  
    `container_name: cache_redis`  
    `restart: always`  
    `ports:`  
      `- "6379:6379"`

`volumes:`  
  `pgdata:`

Ejecutar:

`docker compose up -d`  
`docker ps`

‚úÖ Si ves los contenedores `db_postgres` y `cache_redis` activos, el entorno base est√° listo.

---

### **4Ô∏è‚É£ Crear archivos de entorno**

En la ra√≠z:

`.env.example`

`POSTGRES_USER=devuser`  
`POSTGRES_PASSWORD=devpass`  
`POSTGRES_DB=main_db`  
`REDIS_HOST=redis`  
`REDIS_PORT=6379`

Cada equipo debe copiarlo a `.env` local.

---

### **5Ô∏è‚É£ Registrar en README el dise√±o inicial**

En `README.md` (ra√≠z):

`# Laboratorio de Microservicios (Django + React)`

`## Arquitectura inicial`  
`- auth-service/      ‚Üí Autenticaci√≥n y tokens JWT`  
`- blog-service/      ‚Üí Publicaciones, autores y categor√≠as`  
`- email-service/     ‚Üí Notificaciones y formularios`  
`- frontend/          ‚Üí Interfaz React`  
`- reverse-proxy/     ‚Üí Balanceo / Gateway local`

`Servicios base:`  
`- PostgreSQL (5432)`  
`- Redis (6379)`

---

## **üß™ Mini-reto de cierre del d√≠a**

* Levantar los contenedores (`docker compose up -d`).

* Crear un archivo `test_connection.py` en `auth-service/` que pruebe la conexi√≥n a PostgreSQL y Redis usando variables de entorno.

* Ejecutarlo con `docker exec -it` dentro del contenedor.

---

## **üì¶ Entregables del D√≠a 1**

| Entregable | Descripci√≥n |
| ----- | ----- |
| **Repo Git** | Subido a GitHub con estructura base y `.env.example` |
| **Docker Compose funcional** | Levanta PostgreSQL y Redis sin errores |
| **README documentado** | Incluye arquitectura y checklist |
| **Captura o video corto** | Mostrando los contenedores en ejecuci√≥n (`docker ps`) |

---

## **üß† Evaluaci√≥n**

| Criterio | Peso |
| ----- | ----- |
| Entorno Docker funcionando | 40 % |
| Organizaci√≥n y limpieza del repo | 25 % |
| README claro y completo | 20 % |
| Comunicaci√≥n y trabajo en equipo (Scrum Daily) | 15 % |

# **üß≠ Evaluaci√≥n ‚Äî D√≠a 1: Fundamentos \+ Entorno Docker / Git**

## **üéØ Objetivo**

Comprobar que cada practicante:

* Entiende los principios y beneficios de los microservicios.

* Maneja los comandos b√°sicos de Git y Docker.

* Puede explicar c√≥mo se relaciona la teor√≠a con la pr√°ctica configurada.

---

## **üß† Preguntas te√≥ricas (10 preguntas √ó 2 pts \= 20 pts)**

| N¬∫ | Pregunta | Ponderaci√≥n |
| ----- | ----- | ----- |
| **1** | ¬øQu√© diferencia principal existe entre una arquitectura **monol√≠tica** y una **de microservicios**? | 2 pts |
| **2** | Menciona **dos ventajas** y **dos desventajas** de usar microservicios. | 2 pts |
| **3** | Explica con tus palabras qu√© significa el principio de **responsabilidad √∫nica** en un microservicio. | 2 pts |
| **4** | ¬øQu√© implica tener un **acoplamiento flexible** entre servicios y c√≥mo se logra en Django REST? | 2 pts |
| **5** | ¬øQu√© funci√≥n cumple **Docker Compose** dentro de una arquitectura de microservicios? | 2 pts |
| **6** | ¬øPara qu√© sirve el archivo **.env** y por qu√© no debe subirse al repositorio? | 2 pts |
| **7** | Indica los comandos para **crear una nueva rama**, **hacer un commit** y **subirlo al remoto**. | 2 pts |
| **8** | ¬øQu√© papel cumple **Redis** dentro del ecosistema de microservicios? | 2 pts |
| **9** | ¬øQu√© buenas pr√°cticas del modelo **12 Factor App** aplicaste hoy al crear tu entorno Dockerizado? | 2 pts |
| **10** | Si un contenedor no arranca, ¬øqu√© comando usar√≠as para **inspeccionar logs o errores** y c√≥mo lo resolver√≠as? | 2 pts |

# **üß≠ D√çA 2 ‚Äî Ejercicio 2: BACKEND Microservicio Backend Auth (Django \+ DRF \+ JWT \+ PostgreSQL \+ Redis)**

üéØ **Objetivo general:**  
 Construir un microservicio de autenticaci√≥n completamente independiente, que maneje usuarios, login y tokens JWT, corriendo en su propio contenedor Docker y conectado a PostgreSQL y Redis.

---

## **üß© Conceptos clave**

* Autenticaci√≥n basada en **JWT (JSON Web Tokens)**

* Estructura de un **servicio Django aislado**

* Configuraci√≥n de variables de entorno y dependencias

* Cacheo y sesiones con Redis

* Comunicaci√≥n segura entre servicios v√≠a API

---

## **üïê Video de referencia:**

üé• *‚ÄúMicroservicios con Django REST Framework, Next.js y Apache Kafka‚Äù*  
 üëâ [https://www.youtube.com/watch?v=wj766sxHZrM](https://www.youtube.com/watch?v=wj766sxHZrM&utm_source=chatgpt.com)

üìç **Ver desde:** **minuto 26:13 hasta 2:54:00**

(No ver ni implementar la parte de Kafka Producer ‚Äî solo REST y Redis)

---

## **‚öôÔ∏è Pasos del ejercicio**

### **1Ô∏è‚É£ Crear el proyecto Django y app `users`**

`cd auth-service`  
`django-admin startproject auth_service .`  
`python manage.py startapp users`

### **2Ô∏è‚É£ Configurar el `Dockerfile`**

`FROM python:3.11`  
`WORKDIR /app`  
`COPY requirements.txt .`  
`RUN pip install -r requirements.txt`  
`COPY . .`  
`CMD ["gunicorn", "auth_service.wsgi:application", "--bind", "0.0.0.0:8000"]`

### **3Ô∏è‚É£ Extender `docker-compose.yml`**

`auth:`  
  `build: ./auth-service`  
  `container_name: auth_service`  
  `restart: always`  
  `environment:`  
    `- DEBUG=1`  
    `- DB_HOST=postgres`  
    `- DB_NAME=main_db`  
    `- DB_USER=devuser`  
    `- DB_PASS=devpass`  
    `- REDIS_HOST=redis`  
    `- REDIS_PORT=6379`  
  `depends_on:`  
    `- postgres`  
    `- redis`  
  `ports:`  
    `- "8000:8000"`

---

### **4Ô∏è‚É£ Instalar dependencias (en `requirements.txt`)**

`django==5.0`  
`djangorestframework==3.15`  
`djangorestframework-simplejwt==5.3`  
`psycopg2-binary`  
`redis`  
`django-cors-headers`

---

### **5Ô∏è‚É£ Configurar `settings.py`**

* A√±adir `rest_framework`, `corsheaders`, `users`

* Configurar **DATABASES** con variables de entorno

* Configurar **CACHES** (Redis)

* A√±adir middleware `corsheaders.middleware.CorsMiddleware`

* Definir `REST_FRAMEWORK` con `JWTAuthentication`

---

### **6Ô∏è‚É£ Modelo de usuario personalizado**

En `users/models.py`:

`from django.contrib.auth.models import AbstractBaseUser, BaseUserManager`  
`from django.db import models`

`class UserManager(BaseUserManager):`  
    `def create_user(self, email, password=None):`  
        `if not email:`  
            `raise ValueError("Email obligatorio")`  
        `user = self.model(email=self.normalize_email(email))`  
        `user.set_password(password)`  
        `user.save(using=self._db)`  
        `return user`

`class User(AbstractBaseUser):`  
    `email = models.EmailField(unique=True)`  
    `is_active = models.BooleanField(default=True)`  
    `is_admin = models.BooleanField(default=False)`  
    `USERNAME_FIELD = 'email'`  
    `objects = UserManager()`

    `def __str__(self):`  
        `return self.email`

Registrar en `settings.py`:

`AUTH_USER_MODEL = 'users.User'`

---

### **7Ô∏è‚É£ Endpoints con JWT**

En `users/views.py` o rutas de API:

`from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView`

Configura rutas:

`path('api/token/', TokenObtainPairView.as_view()),`  
`path('api/token/refresh/', TokenRefreshView.as_view()),`

Crea tambi√©n un endpoint `/api/register/` que permita crear usuarios.

---

### **8Ô∏è‚É£ Probar con Postman**

* **POST /api/register/** ‚Üí crea usuario

* **POST /api/token/** ‚Üí genera access/refresh token

* **POST /api/token/refresh/** ‚Üí renueva token

Verificar conexi√≥n con base de datos y Redis:

`docker exec -it auth_service python manage.py shell`

---

## **üß™ Reto adicional (opcional)**

Implementar endpoint `/api/me/` que devuelva la informaci√≥n del usuario autenticado.

---

## **üì¶ Entregables del D√≠a 2**

| Entregable | Descripci√≥n |
| ----- | ----- |
| C√≥digo funcional del microservicio `auth-service/` | Proyecto Django con JWT, PostgreSQL y Redis |
| `Dockerfile` y `docker-compose.yml` actualizados | Contenedor funcionando en puerto 8000 |
| Captura Postman | Evidencia de login, refresh y verify exitosos |
| README actualizado | Descripci√≥n del servicio y endpoints |

---

## **üß† Evaluaci√≥n (0 ‚Äì 20 pts)**

| Criterio | Peso |
| ----- | ----- |
| Estructura y configuraci√≥n del servicio | 5 pts |
| Modelos y endpoints funcionales | 8 pts |
| JWT implementado correctamente | 5 pts |
| Documentaci√≥n y commits limpios | 2 pts |

# **üß≠ Evaluaci√≥n te√≥rica ‚Äî D√≠a 2: Microservicio Auth (Django \+ JWT \+ Redis)**

## **üéØ Objetivo**

Verificar que el practicante comprende **c√≥mo se construye y protege un microservicio de autenticaci√≥n**, c√≥mo se gestiona la **persistencia y el cache**, y c√≥mo se integran los conceptos de **seguridad, desacoplamiento y despliegue**.

---

| N¬∫ | Pregunta | Valor |
| ----- | ----- | ----- |
| **1** | ¬øCu√°l es el prop√≥sito de crear un microservicio de autenticaci√≥n separado en una arquitectura distribuida? | 2 pts |
| **2** | ¬øQu√© diferencia existe entre la autenticaci√≥n basada en **sesiones** y la autenticaci√≥n basada en **tokens JWT**? | 2 pts |
| **3** | Explica brevemente c√≥mo se estructura un **token JWT** (qu√© contiene el *header*, *payload* y *signature*). | 2 pts |
| **4** | ¬øQu√© ventaja ofrece usar **Redis** dentro del microservicio Auth? Da un ejemplo pr√°ctico. | 2 pts |
| **5** | ¬øQu√© es el archivo **Dockerfile** y cu√°l es su funci√≥n en el microservicio Auth? | 2 pts |
| **6** | ¬øPor qu√© es recomendable definir las variables sensibles en un archivo **.env** y no directamente en el c√≥digo fuente? | 2 pts |
| **7** | ¬øQu√© librer√≠a de Django se utiliza para implementar JWT y c√≥mo se integra en `settings.py`? | 2 pts |
| **8** | ¬øQu√© comando de Django se usa para **crear migraciones** y cu√°l para **aplicarlas** dentro del contenedor Docker? | 2 pts |
| **9** | Explica el flujo completo de login con JWT: desde que el usuario env√≠a sus credenciales hasta que accede a un recurso protegido. | 2 pts |
| **10** | Menciona dos buenas pr√°cticas para asegurar un microservicio Auth en producci√≥n (por ejemplo: manejo de tokens, CORS, HTTPS, etc.). | 2 pts |

---

## **üìä Escala de evaluaci√≥n**

| Puntaje | Nivel | Descripci√≥n |
| ----- | ----- | ----- |
| **18 ‚Äì 20** | ‚≠ê Avanzado | Explica conceptos de seguridad y configuraci√≥n con precisi√≥n. |
| **15 ‚Äì 17** | ‚úÖ Competente | Entiende el flujo JWT y maneja Redis/Docker correctamente. |
| **12 ‚Äì 14** | ‚ö†Ô∏è B√°sico | Conoce la teor√≠a pero no puede aplicarla sin gu√≠a. |
| **\< 12** | ‚ùå Insuficiente | No distingue JWT, Redis o configuraci√≥n de entorno. |

# **üß≠ D√çA 3 ‚Äî Ejercicio 3: SALA 4 BACKEND (Hexagonal \+ Microservicios)**

# **El resto de los grupos el ejercicios est√° en la p√°gina 17**

## **Alcance (mismo dominio ‚ÄúBiblioteca Digital‚Äù)**

Microservicios:

* **Loans** (pr√©stamos) ‚Äî foco hexagonal

* **Books** (libros) ‚Äî CRUD simple

* **Users** (usuarios) ‚Äî verificaci√≥n de estado

## **Estructura recomendada (Django)**

`loans_service/`  
  `src/`  
    `domain/`  
      `entities/loan.py`  
      `rules/validators.py`  
      `ports/{users_repo.py, books_repo.py, clock.py, uuid_gen.py}`  
      `services/loan_service.py`  
    `application/`  
      `use_cases/{create_loan_uc.py, return_loan_uc.py}`  
      `dtos/{loan_request_dto.py, loan_response_dto.py}`  
    `infrastructure/`  
      `repositories/{users_repo_http.py, books_repo_http.py, loans_repo_django.py}`  
      `services/{clock_system.py, uuid_native.py}`  
      `configs/container.py   # wiring sencillo (DI light)`  
    `interfaces/api/{serializers.py, views.py, urls.py}`  
  `tests/{unit/, integration/}`

## **Reglas (dominio Loans)**

* M√°ximo **3 pr√©stamos activos** por usuario.

* Duraci√≥n **‚â§ 15 d√≠as**.

* Usuario **activo** y **no suspendido**.

* Libro **disponible** (no eliminado, no ‚Äúprestado‚Äù).

## **Contratos (para integrarse sin bloquearse)**

### **Users (puerto 9000\)**

* `GET /api/users/{id}` ‚Üí `{ id, email, status: "active"|"suspended" }`

* `GET /api/users/{id}/loans/count?status=active` ‚Üí `{ count: number }`

### **Books (puerto 9001\)**

* `GET /api/books/{id}` ‚Üí `{ id, title, status: "available"|"loaned"|"deleted" }`

* `POST /api/books/{id}/mark-loaned` ‚Üí `204`

* `POST /api/books/{id}/mark-returned` ‚Üí `204`

### **Loans (puerto 9002\)**

* `POST /api/loans`  
   **request**: `{ user_id, book_id, start_date (ISO), days }`  
   **response**: `{ loan_id, due_date, status: "active" }`

* `POST /api/loans/{loan_id}/return` ‚Üí `{ status: "returned" }`

* `GET /api/loans/{loan_id}` ‚Üí `{ loan_id, user_id, book_id, start_date, due_date, status }`

**Nota:** Sala 4 puede usar **REST** (no Kafka). A√±adir **timeouts \+ retries** (httpx/requests), y logging estructurado (json) en adaptadores HTTP.

## **DoD (Definition of Done)**

* Dominio sin dependencias de framework (reglas testeadas).

* Puertos \+ adaptadores con **timeouts (‚â§3s)**, **retry (m√°x. 2\)** y manejo de errores.

* **Tests**: ‚â•6 unit (dominio) \+ ‚â•3 integraci√≥n (HTTP/ORM).

* **OpenAPI** m√≠nimo para Loans.

* Docker Compose con `users`, `books`, `loans` (DB por servicio).

* README con arquitectura, c√≥mo correr y ejemplos de cURL.

# **üß≠ Evaluaci√≥n te√≥rica ‚Äî Sala 4 (Hexagonal \+ MS Biblioteca Digital)**

| N¬∫ | Pregunta | Valor |
| ----- | ----- | ----- |
| **1** | Explica con tus palabras qu√© es **Arquitectura Hexagonal** y cu√°l es su objetivo principal. | 2 pts |
| **2** | ¬øQu√© son los **puertos** y los **adaptadores** en Hexagonal? Da un ejemplo concreto del **UsersRepository** o **BooksRepository**. | 2 pts |
| **3** | ¬øPor qu√© el **dominio** (reglas de negocio) debe estar **libre de dependencias** de framework (Django/DRF/ORM)? ¬øQu√© beneficio aporta? | 2 pts |
| **4** | Describe el **flujo para crear un pr√©stamo** en Loans (use case `create_loan`): validaciones y llamadas a otros servicios. | 2 pts |
| **5** | Enumera las **reglas de negocio** obligatorias del dominio Loans (l√≠mite de 3 pr√©stamos, ‚â§15 d√≠as, usuario activo, libro disponible) y explica **d√≥nde** deben implementarse. | 2 pts |
| **6** | ¬øC√≥mo implementar√≠as **timeouts y retries** en los adaptadores HTTP hacia Users/Books y por qu√© son necesarios en microservicios? | 2 pts |
| **7** | ¬øQu√© diferencia hay entre un **test de unidad** del dominio y un **test de integraci√≥n** (por ejemplo, contra el adaptador HTTP u ORM)? | 2 pts |
| **8** | ¬øQu√© debe incluir el **contrato OpenAPI** m√≠nimo del servicio Loans y c√≥mo ayuda al Frontend y a otros equipos? | 2 pts |
| **9** | Explica el principio de **base de datos por microservicio**. ¬øPor qu√© no se comparten tablas entre Loans, Users y Books? | 2 pts |
| **10** | Prop√≥n dos **buenas pr√°cticas de observabilidad** aplicables aqu√≠ (logs estructurados, healthchecks, m√©tricas) y qu√© informaci√≥n registrar√≠as. |  |

# **üß≠ D√çA 3 ‚Äî Backend (todas las salas excepto Sala 4\)**

## **Ejercicio: Blog Service** 

## **Stack:** Django \+ DRF \+ PostgreSQL \+ Redis \+ Docker  **Puerto:** `8001`  **Objetivo:** construir un microservicio **independiente** que exponga posts y categor√≠as con **paginaci√≥n, b√∫squeda y cach√©**, y que **est√© listo** para, m√°s adelante, consumir Auth por REST (JWT) **sin bloquearse hoy**.

---

## **1\) Alcance funcional (MVP)**

* **Modelos**

  * `Category(id, name, slug, is_active)`

  * `Author(id, display_name, email)` *(por hoy: seed local; ma√±ana se enlaza a Auth)*

  * `Post(id, title, slug, body, author(FK), category(FK), status[published|draft], published_at, views)`

* **Endpoints (p√∫blicos hoy; privados ma√±ana)**

  * `GET /api/categories` ‚Üí lista categor√≠as activas

  * `GET /api/posts?search=&page=` ‚Üí lista con b√∫squeda (t√≠tulo/body) \+ paginaci√≥n

  * `GET /api/posts/{id|slug}` ‚Üí detalle

* **Cach√© (Redis)**

  * Cachear `GET /api/categories` y `GET /api/posts/{id|slug}` (TTL 60‚Äì120s)

* **Observabilidad**

  * `GET /healthz` (DB \+ Redis OK)

  * Logging estructurado (JSON) por request

**Opcional hoy (dejar esqueleto):** middleware que lea `Authorization: Bearer ...` y **no valide** todav√≠a (solo loguea el header). Ma√±ana se conecta al Auth real.

---

## **2\) Estructura del proyecto**

`blog-service/`

  `app/`

    `blog_service/            # proyecto Django`

    `core/                    # utilidades (cache helpers, pagination)`

    `categories/              # app`

    `authors/                 # app`

    `posts/                   # app`

  `Dockerfile`

  `requirements.txt`

  `manage.py`

  `openapi.yaml               # contrato m√≠nimo`

### **`requirements.txt`**

`Django==5.0`

`djangorestframework==3.15`

`psycopg2-binary`

`django-redis`

`django-filter`

`python-slugify`

---

## **3\) Docker (servicio y compose)**

**Dockerfile**

`FROM python:3.11`

`WORKDIR /app`

`COPY requirements.txt .`

`RUN pip install -r requirements.txt`

`COPY . .`

`CMD ["gunicorn", "blog_service.wsgi:application", "--bind", "0.0.0.0:8001"]`

**docker-compose.yml** (extiende el que ya tienen)

`blog:`

  `build: ./blog-service`

  `container_name: blog_service`

  `environment:`

    `- DB_HOST=postgres`

    `- DB_NAME=main_db`

    `- DB_USER=devuser`

    `- DB_PASS=devpass`

    `- REDIS_HOST=redis`

    `- REDIS_PORT=6379`

    `- DEBUG=1`

  `depends_on:`

    `- postgres`

    `- redis`

  `ports:`

    `- "8001:8001"`

---

## **4\) DRF r√°pido (paginaci√≥n, filtro, cach√©)**

* **Paginaci√≥n:** DRF `PAGE_SIZE=10`

* **B√∫squeda:** `django-filter` o `?search=` simple sobre `title`/`body`

* **Cach√© Redis:** `django-redis` \+ decorador `cache_page` en `categories` y `post detail`

Ejemplo `views.py (posts)`

`from django.views.decorators.cache import cache_page`

`from django.utils.decorators import method_decorator`

`from rest_framework import viewsets, mixins`

`from .models import Post`

`from .serializers import PostListSerializer, PostDetailSerializer`

`@method_decorator(cache_page(60), name="retrieve")   # detalle cacheado 60s`

`class PostViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet):`

    `queryset = Post.objects.filter(status="published").select_related("author", "category")`

    `def get_serializer_class(self):`

        `return PostDetailSerializer if self.action == "retrieve" else PostListSerializer`

---

## **5\) Datos de ejemplo (seed)**

Crear `management/commands/seed_blog.py` para cargar:

* 5 categor√≠as

* 3 autores

* 30 posts variados (algunos draft)

---

## **6\) Healthcheck y logging**

* `GET /healthz` verifica conexi√≥n a DB y ping a Redis.

* Logging JSON por request (m√©todo, path, status, tiempo).

---

## **7\) Contrato OpenAPI m√≠nimo (front puede trabajar ya)**

* `GET /api/categories` ‚Üí `[{id, name, slug}]`

* `GET /api/posts?search=&page=` ‚Üí `results:[{id, title, slug, excerpt, author:{id,display_name}, category:{id,name}, published_at}]`

* `GET /api/posts/{id|slug}` ‚Üí `{id, title, body, author:{...}, category:{...}, published_at, views}`

*(Gu√°rdalo en `openapi.yaml` y comp√°rtelo con Front.)*

---

## **8\) Entregables del d√≠a**

* Servicio corriendo en `:8001` (Docker)

* Endpoints funcionando \+ paginaci√≥n \+ b√∫squeda

* Cache Redis en `categories` y `post detail`

* `seed_blog` ejecutado y documentado

* `openapi.yaml` publicado

* README con c√≥mo correr, seeds y ejemplos cURL

---

## **9\) Evaluaci√≥n (0‚Äì20 pts)**

| Criterio | Pts |
| ----- | ----- |
| Modelos \+ migraciones limpias | 4 |
| Endpoints (lista, detalle, categor√≠as) | 6 |
| Paginaci√≥n \+ b√∫squeda | 3 |
| Cach√© Redis en endpoints clave | 3 |
| Healthcheck \+ logging b√°sico | 2 |
| README \+ OpenAPI m√≠nimo | 2 |

---

## **10\) Preguntas te√≥ricas (10 √ó 2 \= 20 pts)**

1. ¬øPor qu√© **blog** debe tener su **propia base de datos** en microservicios?

2. Diferencia entre **cach√© de p√°gina** y **cach√© de fragmento** (y cu√°ndo usar cada una).

3. ¬øQu√© riesgo hay al **no invalidar** cach√© y c√≥mo mitigarlo en este ejercicio?

4. ¬øQu√© aporta la **paginaci√≥n** y qu√© m√©tricas de rendimiento observar√≠as?

5. ¬øPor qu√© preferimos **b√∫squeda server-side** en listados grandes?

6. ¬øQu√© ventajas ofrece `select_related/prefetch_related`?

7. Explica el rol de un **healthcheck** en entornos orquestados.

8. ¬øQu√© campos de **logging** son √∫tiles para depurar latencia?

9. ¬øC√≥mo preparar√≠as el servicio para exigir **JWT** m√°s adelante sin romper al frontend?

10. ¬øQu√© estrategias usar√≠as para evitar **N+1 queries** en endpoints de lista?

# **üß≠ D√çA 4 ‚Äî \- 28/10/ 2025 Backend: Email / Notifications Service**

üì¶ **Puerto sugerido:** `8002`  
 üìö **Nivel:** Intermedio (enfocado en integraci√≥n y comunicaci√≥n entre servicios)

---

## **üéØ Objetivo general**

Construir un **microservicio independiente de notificaciones (Email Service)** que:

* Reciba mensajes o formularios desde otros microservicios (p. ej. Blog o Auth).

* Env√≠e correos simulados (o reales si se tiene configuraci√≥n SMTP).

* Ejemplifique **comunicaci√≥n entre microservicios** por **HTTP** y **colas** (opcional).

* Refuerce conceptos de **idempotencia**, **reintentos** y **observabilidad**.

---

## **‚öôÔ∏è Requisitos t√©cnicos**

* **Stack:** Django \+ DRF \+ Redis \+ Docker \+ (opcional Celery)

* **Base de datos:** independiente (PostgreSQL o SQLite local)

* **Servicios relacionados:** Auth (8000) y Blog (8001) solo como emisores; Email recibe.

---

## **üß© Requisitos funcionales**

### **1Ô∏è‚É£ Endpoint principal**

`POST /api/contact/`

`{`  
  `"name": "Carlos Rivas",`  
  `"email": "carlos@mail.com",`  
  `"message": "Me interesa una colaboraci√≥n"`  
`}`

**Respuesta**

`{ "status": "queued" }`

* Valida campos requeridos.

* Persiste la solicitud en la BD (`ContactMessage`).

* Env√≠a una notificaci√≥n (simulada por consola o archivo log).

### **2Ô∏è‚É£ Endpoint interno (opcional)**

`POST /api/notify/`

`{`  
  `"to": "user@mail.com",`  
  `"subject": "Nuevo post publicado",`  
  `"body": "..."`  
`}`

‚Üí Simula un evento recibido desde Blog u otro servicio.

---

## **üèóÔ∏è Estructura recomendada**

`email-service/`  
 `‚îú‚îÄ‚îÄ app/`  
 `‚îÇ   ‚îú‚îÄ‚îÄ notifications/`  
 `‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ models.py      # ContactMessage, NotificationLog`  
 `‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ serializers.py`  
 `‚îÇ   ‚îÇ    ‚îú‚îÄ‚îÄ views.py       # ContactViewSet, NotifyViewSet`  
 `‚îÇ   ‚îÇ    ‚îî‚îÄ‚îÄ tasks.py       # (si usan Celery)`  
 `‚îÇ   ‚îî‚îÄ‚îÄ utils/`  
 `‚îÇ        ‚îú‚îÄ‚îÄ mailer.py      # funci√≥n send_email()`  
 `‚îÇ        ‚îî‚îÄ‚îÄ logger.py`  
 `‚îú‚îÄ‚îÄ Dockerfile`  
 `‚îú‚îÄ‚îÄ requirements.txt`  
 `‚îú‚îÄ‚îÄ manage.py`  
 `‚îú‚îÄ‚îÄ openapi.yaml`

---

## **‚öôÔ∏è Configuraci√≥n m√≠nima**

**Dependencias**

`Django==5.0`  
`djangorestframework==3.15`  
`django-cors-headers`  
`psycopg2-binary`  
`redis`  
`celery==5.4  # opcional`

**Correo simulado (settings.py)**

`EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"`

(O bien `filebased.EmailBackend` para guardar en carpeta `/sent_emails`.)

---

## **üîÅ Opcional: Celery \+ Redis (worker as√≠ncrono)**

* Definir cola `emails`.

* Encolar las tareas de env√≠o en segundo plano.

* Configurar retry m√°x. 3, delay 5 s.

---

## **üîç Observabilidad y resiliencia**

* Healthcheck `/healthz` (DB \+ Redis).

* Logs estructurados (JSON): entrada, salida, tiempo de procesamiento.

* Reintento con backoff si fallan llamadas HTTP entrantes.

* Idempotencia (basada en UUID del mensaje).

---

## **üì¶ Entregables**

| Entregable | Descripci√≥n |
| ----- | ----- |
| Microservicio Email funcional | `POST /api/contact` almacena y simula env√≠o |
| Healthcheck \+ logging | `/healthz` y logs estructurados |
| OpenAPI documentado | Endpoints contact/notify |
| (Opcional) Celery \+ Redis | Reintentos as√≠ncronos |
| README | C√≥mo correr \+ ejemplos cURL \+ docker-compose |

---

## **üß† Evaluaci√≥n (0‚Äì20 pts)**

| Criterio | Pts |
| ----- | ----- |
| Endpoints funcionales / validaciones | 5 |
| Persistencia de mensajes | 3 |
| Simulaci√≥n de env√≠o o worker Celery | 4 |
| Logs \+ healthcheck | 3 |
| Docker / README / OpenAPI | 3 |
| (Bonus) Retry / Idempotencia | 2 |

---

## **üí¨ Preguntas te√≥ricas (10 √ó 2 \= 20 pts)**

1Ô∏è‚É£ ¬øQu√© ventaja aporta separar las notificaciones en un microservicio independiente?  
 2Ô∏è‚É£ Explica la diferencia entre **env√≠o s√≠ncrono** y **as√≠ncrono** de correos.  
 3Ô∏è‚É£ ¬øQu√© es una **cola de mensajes** y cu√°ndo conviene usarla en este caso?  
 4Ô∏è‚É£ ¬øQu√© problemas resuelve Celery en arquitecturas distribuidas?  
 5Ô∏è‚É£ ¬øC√≥mo podr√≠as asegurar la **idempotencia** de un env√≠o de correo?  
 6Ô∏è‚É£ ¬øPor qu√© es √∫til tener un endpoint interno (`/notify`) para otros servicios?  
 7Ô∏è‚É£ ¬øQu√© deber√≠a verificar un **healthcheck** en este servicio?  
 8Ô∏è‚É£ ¬øQu√© campos incluir√≠as en un **log estructurado** de notificaci√≥n?  
 9Ô∏è‚É£ ¬øC√≥mo manejar√≠as un **error de SMTP** sin bloquear el servicio?  
 üîü ¬øQu√© estrategias usar√≠as para **probar as√≠ncronamente** el env√≠o de correos?

Para la **SALA 4 ‚Äì BACKEND (Hexagonal \+ Microservicios)** el siguiente paso es **cerrar el flujo de ‚ÄúPr√©stamo end-to-end‚Äù** con arquitectura hexagonal en `Loans`, usando `Users` y `Books` m√≠nimos (REST), sin Kafka.

# **Siguiente ejercicio ‚Äî Sala 4 \- 28/10/ 2025 (Hexagonal)**

## **üéØ Objetivo**

Entregar el **MVP completo de Loans** con dominio puro (reglas), puertos/adaptadores, tests y **comunicaci√≥n real** con `Users` y `Books` por HTTP. Todo dockerizado y documentado.

## **ü™ú Tareas (orden sugerido)**

1. **Dominio (Loans) listo**

   * Reglas: `‚â§3` pr√©stamos activos / usuario, duraci√≥n `‚â§15` d√≠as, usuario activo, libro disponible.

   * Casos de uso: `create_loan` y `return_loan`.

   * Entidades/DTOs: `Loan`, `LoanRequestDTO`, `LoanResponseDTO`.

2. **Puertos y Adaptadores**

   * Puertos: `UsersRepository`, `BooksRepository`, `Clock`, `UUIDGen`, `LoansRepository`.

   * Adaptadores:

     * HTTP `users_repo_http` (GET `/api/users/{id}`, GET `/api/users/{id}/loans/count?status=active`).

     * HTTP `books_repo_http` (GET `/api/books/{id}`, POST `/mark-loaned`, `/mark-returned`).

     * ORM `loans_repo_django`.

3. **Resiliencia obligatoria**

   * **Timeout ‚â§3s** y **retry x2** en adaptadores HTTP (requests/httpx).

   * Manejo de errores (time-out, 4xx/5xx) ‚Üí mapear a errores de dominio.

   * Logging estructurado (JSON) con latencia y outcome.

4. **Interfaces (DRF)**

   * `POST /api/loans` ‚Üí `{loan_id, due_date, status:"active"}`

   * `POST /api/loans/{loan_id}/return` ‚Üí `{status:"returned"}`

   * `GET /api/loans/{loan_id}` ‚Üí detalle

5. **Servicios auxiliares m√≠nimos**

   * **Users** y **Books** como servicios simples (o mocks HTTP con seed) que respeten los **contratos acordados**.

   * Cada servicio con su **DB propia**.

6. **OpenAPI \+ Compose**

   * `openapi.yaml` de **Loans** publicado.

   * `docker-compose` con `users`, `books`, `loans`, `postgres` (por servicio) y `redis` (si lo usan para cache/counter).

7. **Tests**

   * **Unidad (dominio):** ‚â•6 (reglas y casos de uso).

   * **Integraci√≥n:** ‚â•3 (HTTP a Users/Books con timeouts/retry \+ ORM Loans).

## **üì¶ Entregables**

* Repos de `loans_service`, `users_service`, `books_service`.

* `openapi.yaml` de Loans.

* `docker-compose.yml` para levantar todo.

* README con: arquitectura, c√≥mo correr, ejemplos `curl`, y tabla de errores (mapeo HTTP‚Üídominio).

## **üß† Evaluaci√≥n (0‚Äì20)**

| Criterio | Pts |
| ----- | ----- |
| Dominio (reglas \+ casos de uso) aislado de framework | 5 |
| Puertos/adaptadores con timeout \+ retry \+ manejo de errores | 5 |
| Endpoints DRF funcionales | 4 |
| Tests (unidad \+ integraci√≥n) | 4 |
| OpenAPI \+ Compose \+ README | 2 |

Nota: **No Kafka a√∫n.** Si terminan antes, bonus: **idempotencia** en `create_loan` (evitar doble pr√©stamo ante reintentos) y **m√©tricas simples** (contadores por outcome).

# **Evaluaci√≥n te√≥rica ‚Äì Sala 4: Arquitectura Hexagonal \+ Microservicios**

| N¬∫ | Pregunta | Valor |
| ----- | ----- | ----- |
| **1** | ¬øCu√°l es la diferencia principal entre una arquitectura **en capas tradicional** y la **arquitectura hexagonal**? | 2 pts |
| **2** | ¬øQu√© son los **puertos** y los **adaptadores**, y c√≥mo ayudan a mantener el c√≥digo desacoplado del framework? | 2 pts |
| **3** | En el microservicio Loans, ¬øpor qu√© el dominio no debe importar Django ni DRF? ¬øQu√© ventaja ofrece esta independencia? | 2 pts |
| **4** | Describe paso a paso qu√© ocurre en el caso de uso **create\_loan**: desde que llega la solicitud hasta que se registra el pr√©stamo. | 2 pts |
| **5** | ¬øQu√© reglas de negocio deben cumplirse antes de crear un pr√©stamo? ¬øD√≥nde se validan dentro de la arquitectura hexagonal? | 2 pts |
| **6** | Explica c√≥mo se manejan los **errores de comunicaci√≥n HTTP** entre Loans y Users/Books (timeouts, reintentos, mapeo de errores). | 2 pts |
| **7** | ¬øQu√© diferencia hay entre un **test de unidad** en el dominio y un **test de integraci√≥n** de los adaptadores HTTP u ORM? | 2 pts |
| **8** | ¬øPor qu√© cada microservicio (Loans, Users, Books) debe tener su **propia base de datos**? ¬øQu√© problemas evita esta separaci√≥n? | 2 pts |
| **9** | ¬øQu√© informaci√≥n incluir√≠as en los **logs estructurados** para mejorar la observabilidad y depuraci√≥n del sistema? | 2 pts |
| **10** | ¬øQu√© beneficios obtiene el equipo al documentar los endpoints en **OpenAPI**, y c√≥mo ayuda esto al frontend o a otros servicios? | 2 pts |

---

## **üìä Escala de calificaci√≥n**

| Puntaje | Nivel | Descripci√≥n |
| ----- | ----- | ----- |
| **18‚Äì20** | ‚≠ê Avanzado | Comprende a fondo el patr√≥n hexagonal y su aplicaci√≥n en Loans. |
| **15‚Äì17** | ‚úÖ Competente | Entiende la estructura y sabe ubicar reglas y adaptadores. |
| **12‚Äì14** | ‚ö†Ô∏è B√°sico | Identifica los elementos pero confunde responsabilidades. |
| **\< 12** | ‚ùå Insuficiente | No distingue dominio, infraestructura ni puertos. |

---

¬øDeseas que te prepare tambi√©n los **√≠tems pr√°cticos (5 evaluables)** para esta Sala 4 ‚Äîpor ejemplo: validaci√≥n de reglas, timeout \+ retry, tests, logs y OpenAPI‚Äî con r√∫brica de 0 a 20?

